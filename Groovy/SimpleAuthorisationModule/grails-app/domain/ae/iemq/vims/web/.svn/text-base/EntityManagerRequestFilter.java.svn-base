package ae.iemq.vims.web;

import java.io.IOException;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.PersistenceException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.tapestry.Tapestry;
import org.apache.tapestry.services.ServiceConstants;
import org.apache.tapestry.services.WebRequestServicer;
import org.apache.tapestry.services.WebRequestServicerFilter;
import org.apache.tapestry.web.WebRequest;
import org.apache.tapestry.web.WebResponse;
import org.springframework.dao.DataAccessResourceFailureException;
import org.springframework.orm.jpa.EntityManagerHolder;
import org.springframework.transaction.support.TransactionSynchronizationManager;

/**
 * A filter that is part of the execution chain for every HTTP request.  It implements
 * the OpenEntityManagerInView pattern (equals the Hibernate OpenSessionInView pattern)
 * whereby for every single request a JPA entity manager is opened and attached to the
 * servicing thread. 
 *
 */
public class EntityManagerRequestFilter implements WebRequestServicerFilter {

	private static Log logger = LogFactory
			.getLog(EntityManagerRequestFilter.class);

	private EntityManagerFactory entityManagerFactory;

	/* (non-Javadoc)
	 * @see org.apache.tapestry.services.WebRequestServicerFilter#service(org.apache.tapestry.web.WebRequest, org.apache.tapestry.web.WebResponse, org.apache.tapestry.services.WebRequestServicer)
	 */
	public void service(WebRequest request, WebResponse response,
			WebRequestServicer servicer) throws IOException {

		String svcValue = request.getParameterValue(ServiceConstants.SERVICE);

		if (Tapestry.ASSET_SERVICE.equals(svcValue)) {
			servicer.service(request, response);
			return;
		}

		EntityManager entityManager = null;
		boolean participate = false;

		if (TransactionSynchronizationManager.hasResource(entityManagerFactory)) {
			entityManager = (EntityManager) TransactionSynchronizationManager
					.getResource(entityManagerFactory);
			participate = true;

		} else {

			try {
				entityManager = entityManagerFactory.createEntityManager();
//				entityManager.getTransaction().begin();

				TransactionSynchronizationManager.bindResource(
						entityManagerFactory, new EntityManagerHolder(
								entityManager));

			} catch (PersistenceException ex) {
				throw new DataAccessResourceFailureException(
						"Could not create JPA EntityManager", ex);
			}
		}

//		reassociateEntities(entityManager, request);
		
		try {
			servicer.service(request, response);
		} finally {
			if (participate)
				return;

			TransactionSynchronizationManager
			.unbindResource(entityManagerFactory);

//			attemptCommit(entityManager);
			entityManager.close();
		}
	}

	/**
	 * Implements the transaction-per-request pattern.  This is disabled at present in favour
	 * of annotation-based transaction demarcation in the service layer.
	 * @param entityManager
	 */
	private void attemptCommit(EntityManager entityManager) {
		EntityTransaction transaction = entityManager.getTransaction();

		if (!transaction.isActive()) {
			logger.info("Transaction was found inactive, no commit or rollback will be attempted");			
			return;
		}
		
		try {
			transaction.commit();			

		} catch (RuntimeException ex) {
			logger
					.error(
							"Unexpected exception on closing Hibernate EntityManager",
							ex);

			if (transaction.isActive())
				transaction.rollback();
		}
	}


	/**
	 * Spring-injected entity manager factory
	 * @param entityManagerFactory
	 */
	public void setEntityManagerFactory(
			EntityManagerFactory entityManagerFactory) {
		this.entityManagerFactory = entityManagerFactory;
	}

}
